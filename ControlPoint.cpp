/*
 * Common routines that are generic across control points
 *
 *    Copyright (c) 2013-2015 John Plocher
 *    Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)
 */

#include <Arduino.h>
#include <ControlPoint.h>
#include <LocoNet.h>
#include <EEPROM.h>


// #define DEBUG

void ControlPoint::initializeCodeLine(int lnrx, int lntx) {
    pinMode(lntx, OUTPUT);     // Loconet Send Data     (7)
    pinMode(lnrx, INPUT);      // Loconet RxD			(8)
    LocoNet.init(lntx);     // initialize the LocoNet interface
}

// utility routine, used for debugging low mwmory problems...
int ControlPoint::freeRam () {
  extern int __heap_start, *__brkval; 
  int v; 
  return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval); 
}

// Initialize any control point specifics...
int savedcontrols[8];
int usesavedstate = 0;
void ControlPoint::setup(void) {
	usesavedstate = 0;
	restorestate();
}

/* 
 *  EEPROM memory map
 *
 *      0     flag == 42
 *      1     checksum of control packet
 *      2-9   unused
 *     10     controls[0]
 *     11     controls[1]
 *     12     controls[2]
 *     13     controls[3]
 *     14     controls[4]
 *     15     controls[5]
 *     16     controls[6]
 *     17     controls[7]
 *     19-... unused
 *
 */
void ControlPoint::savestate(int *controls) {
	// save last state in EEPROM, restore on restart...
	byte csum = 0;
	EEPROM.write(0, 42);
	for (int x = 0; x < 7; x++) {
		EEPROM.write(10+x, controls[x]);
		csum += controls[x];
	}
	EEPROM.write(1, csum);
}
void ControlPoint::restorestate(void) {
	byte csum;
	byte goodinfo = 1;
	
	if (EEPROM.read(0) != 42) {
		goodinfo = 0;
	}
	for (int x = 0; x < 7; x++) {
		savedcontrols[x] = EEPROM.read(10+x);
		csum += savedcontrols[x];
	}
	if (csum != EEPROM.read(1)) {
		goodinfo = 0;
	}
	
	if (goodinfo) {
		usesavedstate = 1;
	} else {
		// no state to restore, so be safe
		// set all switches to NORMAL, all signals to STOP
		for (int x = 0; x <  getNumSwitches(); x++) {
	        sw[x].set(Switch::NORMAL);
	    }
	    for (int x = 0; x <  getNumSignals(); x++) {
	        sig[x].knockdown();
	        sig[x].report();
	    }
	}
}

int ControlPoint::LnPacket2Controls(int *src, int *dst, int *controls) {
	lnMsg *LnPacket;
	if (usesavedstate) {  // use saved state from last valid control packet to restore control point
		for (int x = 0; x < 7; x++) {
			controls[x] = savedcontrols[x];
			savedcontrols[x] = 0; // prevent reuse...
		}
		usesavedstate = 0;
		return 2;
	} else if ((LnPacket = LocoNet.receive())) {
	    unsigned char opcode = (int)LnPacket->sz.command;
	    *src = (byte)LnPacket->px.src;
	    *dst = (((byte)LnPacket->px.dst_h & 0x7f) << 7) | ((byte)LnPacket->px.dst_l & 0x7f);
	    if (opcode == OPC_PEER_XFER) {
	        controls[0] = (byte)LnPacket->px.d1;  
	        controls[1] = (byte)LnPacket->px.d2;  
	        controls[2] = (byte)LnPacket->px.d3;
	        controls[3] = (byte)LnPacket->px.d4;
	        controls[4] = (byte)LnPacket->px.d5;  
	        controls[5] = (byte)LnPacket->px.d6;  
	        controls[6] = (byte)LnPacket->px.d7;
	        controls[7] = (byte)LnPacket->px.d8;
	        if ((byte)LnPacket->px.pxct1 & B00000001) controls[0] |= B10000000;
	        if ((byte)LnPacket->px.pxct1 & B00000010) controls[1] |= B10000000;
	        if ((byte)LnPacket->px.pxct1 & B00000100) controls[2] |= B10000000;
	        if ((byte)LnPacket->px.pxct1 & B00001000) controls[3] |= B10000000;
         
	        if ((byte)LnPacket->px.pxct2 & B00000001) controls[4] |= B10000000;
	        if ((byte)LnPacket->px.pxct2 & B00000010) controls[5] |= B10000000;
	        if ((byte)LnPacket->px.pxct2 & B00000100) controls[6] |= B10000000;
	        if ((byte)LnPacket->px.pxct2 & B00001000) controls[7] |= B10000000;
	        return 1;
	    }
    }
    return 0;
}

boolean ControlPoint::readall(void) {
    boolean somethingchanged = false; 
    int x;  
    // Read all the inputs from the cTc Panel...
    for (x = 0; x < getNumPorts(); x++) {
        m[x].get();
        somethingchanged |= m[x].changed();
    }  

    if (somethingchanged) {
        // Pick out bits from the layout and populate the various data structures
        // Track Circuits
        for (x = 0; x < getNumTrackCircuits(); x++) { 
          track[x].unpack();
        }
        // Switch position feedback
        for (x = 0; x < getNumSwitches(); x++) { 
          sw[x].unpack();
        }
    } 

    // Run a switch in slow motion if needed...
    // This is a simulated delay for the points to actually move, so the final indication packet
    // generated by a change from Normal to Reverse (or vice versa) isn't sent immediatly.  
    for (int x = 0; x < getNumSwitches(); x++) {
        Switch::Timer cc = sw[x].runSlowMotion();
        somethingchanged |= (cc == Switch::EXPIRED);
    }
    return somethingchanged;
}

/*
 * write out all the output device bits to the layout
 */
void ControlPoint::writeall(void) {
    // Take high level state and pack it up for output to the layout
    for (int x = 0; x < getNumPorts(); x++) {
        m[x].next = 0;    /// Start with a known state
    }
    // pack new "output" bits 
    // Switches  
    for (int x = 0; x < getNumSwitches(); x++) { 
        sw[x].pack();
    }
    // Signals  
    for (int x = 0; x < getNumHeads(); x++) { 
        head[x].pack();
    }
    // Maintainer Call(s)
    for (int x = 0; x < getNumCalls(); x++) { 
        mc[x].pack();
    }
	//Serial.("M[0]="); ControlPoint::printBin(m[0].next);Serial.println();
	//Serial.print("M[1]="); ControlPoint::printBin(m[1].next);Serial.println();
    for (int x = 0; x < getNumPorts(); x++) {
        m[x].put();   // push the .next contents out to the field
    }
}


/*
 * Get "X" by name  functions
 */

int ControlPoint::getSignal(char *name) {
	int x;
	for (x = 0; x < getNumSignals(); x++) { 
		if (sig[x].named(name)) break;
	}
	return (x != getNumSignals()) ? x : -1;
}
int ControlPoint::getSwitch(char *name) {
	int x;
	for (x = 0; x < getNumSwitches(); x++) { if (sw[x].named(name)) break; }
	return (x != getNumSwitches()) ? x : -1;
}
int ControlPoint::getHead(char *name) {
	int x;
	for (x = 0; x < getNumHeads(); x++) { if (head[x].named(name)) break; }
	return (x != getNumHeads()) ? x : -1;    
}
int ControlPoint::getTrack(char *name) {
	int x;
	for (x = 0; x < getNumTrackCircuits(); x++) { if (track[x].named(name)) break; }
	return (x != getNumTrackCircuits()) ? x : -1;
}



int ControlPoint::sendCodeLine(int from, int to, int *indications) {

	lnMsg SendPacket ;

	SendPacket.data[ 0 ] = OPC_PEER_XFER ;
	SendPacket.data[ 1 ] = 0x10;                // packet length
	SendPacket.data[ 2 ] = (from);              // SRC
	SendPacket.data[ 3 ] =  (to & 0x7F);        // DSTL
	SendPacket.data[ 4 ] =  (to >> 7) & 0x7F;   // DSTH 

	int pxct = 0x00;
	if (indications[0] & 0x80) pxct |= B0001;
	if (indications[1] & 0x80) pxct |= B0010;
	if (indications[2] & 0x80) pxct |= B0100;
	if (indications[3] & 0x80) pxct |= B1000;

	SendPacket.data[ 5 ] =  pxct;    // pxct1
	SendPacket.data[ 6 ] = indications[0] & 0x7F;  
	SendPacket.data[ 7 ] = indications[1] & 0x7F;  
	SendPacket.data[ 8 ] = indications[2] & 0x7F;  
	SendPacket.data[ 9 ] = indications[3] & 0x7F;  

	pxct = 0x10;
	if (indications[4] & 0x80) pxct |= B0001;
	if (indications[5] & 0x80) pxct |= B0010;
	if (indications[6] & 0x80) pxct |= B0100;
	if (indications[7] & 0x80) pxct |= B1000;

	SendPacket.data[ 10 ] = pxct;    // pxct2
	SendPacket.data[ 11 ] = indications[4] & 0x7F;  
	SendPacket.data[ 12 ] = indications[5] & 0x7F;  
	SendPacket.data[ 13 ] = indications[6] & 0x7F;  
	SendPacket.data[ 14 ] = indications[7] & 0x7F;   
	 
    byte checksum = 0xFF; 
	for (int i = 0; i < 15; i++) {
      checksum ^= SendPacket.data[i];
    }
    SendPacket.data[ 15 ] = checksum; //checksum  
#ifdef LNDEBUG  
    Serial.print("Send: OPC_PEER_XFER ");
	ControlPoint::printLnPacket(&SendPacket);
#endif
    return (int)LocoNet.send( &SendPacket );   
}


#ifdef DEBUG
void ControlPoint::printEverything(void) {
	int x;
	Serial.println("----");
	for (x = 0; x < getNumSignals(); x++) 		{ sig[x]  .print(); Serial.println();}
	for (x = 0; x < getNumSwitches(); x++)		{ sw[x]   .print(); Serial.println();}
	for (x = 0; x < getNumHeads(); x++)			{ head[x] .print(); Serial.println();}
	for (x = 0; x < getNumTrackCircuits(); x++) { track[x].print(); Serial.println();}
	for (x = 0; x < getNumCalls(); x++) 		{ mc[x]   .print(); Serial.println();}
}

void ControlPoint::printBin(byte x) { // 0 1 2 3 4 5 6 7
	char buff[8+1];
    for (int i = 0; i < 8; i++) {
		buff[i] = (bitRead(x,i) ? '1' : '0');
    }
	buff[8] = '\0';
    Serial.print(buff);
}
void ControlPoint::printBinReverse(byte x) { // 7 6 5 4 3 2 1 0
	char buff[8+1];
    for (int i = 0; i < 8; i++) {
		buff[7-i] = (bitRead(x,i) ? '1' : '0');
    }
	buff[8] = '\0';
    Serial.print(buff);
}
void ControlPoint::printBinOriginal(byte x) {
    for (int i = 7; i >= 0; i++) {
        if (x < pow(2, i)) {
            Serial.print(B0);
        }
    }
    if (x != 0) Serial.print(x, BIN );
}

void ControlPoint::printControls(int from, int to, int *controls) {
	ControlPoint::printPacket("Controls",from, to, controls);
}
void ControlPoint::printIndications(int from, int to, int *indications) {
	ControlPoint::printPacket("Indications",from, to, indications);
}
void ControlPoint::printPacket(char *name, int from, int to, int *packet) {
	Serial.print(name);Serial.print(": FROM: "); Serial.print(from, DEC); Serial.print(", TO: ");Serial.print(to, DEC);Serial.println();
	for (int x = 0; x < 8; x++) {
		Serial.print(x,DEC); Serial.print(": [");ControlPoint::printBin(packet[x]);Serial.print("]\n");
	}
}

void ControlPoint::printLnPacket(lnMsg *LnPacket) {
    uint8_t msgLen = getLnMsgSize(LnPacket); 
    unsigned char opcode = (int)LnPacket->sz.command;
    if (opcode == OPC_PEER_XFER) {
        Serial.print  (LnPacket->data[0], HEX); Serial.print(" "); Serial.println(LnPacket->data[1], HEX); 
        Serial.print("    SRC  = 0x"); Serial.println(LnPacket->data[2], HEX);
        Serial.print("    DST  = 0x"); Serial.print(LnPacket->data[3], HEX);Serial.print(" 0x"); Serial.print(LnPacket->data[4], HEX); Serial.print(" = ");
            Serial.println((LnPacket->data[3] & 0x7F) | ((LnPacket->data[4] & 0x7F) << 7));
        Serial.print("    PXCT1, D1-4  = "); printBin(LnPacket->data[5]); Serial.print(": ");
            for (int x = 6; x <= 9; x++) {    Serial.print(" ");printBin(LnPacket->data[x]);  } Serial.println("");
        Serial.print("    PXCT2, D5-8  = "); printBin(LnPacket->data[10]); Serial.print(": ");
            for (int x = 11; x <= 14; x++) {    Serial.print(" ");printBin(LnPacket->data[x]);  } Serial.println("");
        Serial.print("    CHK  = 0x"); Serial.println(LnPacket->data[15], HEX);
    } else for (uint8_t x = 0; x < msgLen; x++) {
      uint8_t val = LnPacket->data[x];
      if (val < 2)   Serial.print('0');
      if (val < 4)   Serial.print('0'); 
      if (val < 8)   Serial.print('0');  
      if (val < 16)  Serial.print('0');  
      if (val < 32)  Serial.print('0'); 
      if (val < 64)  Serial.print('0');
      if (val < 128) Serial.print('0');
      Serial.print(val, BIN);
      Serial.print(' ');
    }
}
#endif

