/*
 * Common routines that are generic across control points
 *
 * Copyright 2014 John Plocher, released under the terms of the MIT License (MIT)
 */

#include <Arduino.h>
#include <ControlPoint.h>
#include <LocoNet.h>

// #define DEBUG

boolean ControlPoint::readall(void) {
    boolean somethingchanged = false; 
    int x;  
    // Read all the inputs from the cTc Panel...
    for (x = 0; x < getNumPorts(); x++) {
        m[x].get();
        somethingchanged |= m[x].changed();
    }  

    if (somethingchanged) {
        // Pick out bits from the layout and populate the various data structures
        // Track Circuits
        for (x = 0; x < getNumTrackCircuits(); x++) { 
          track[x].unpack();
        }
        // Switch position feedback
        for (x = 0; x < getNumSwitches(); x++) { 
          sw[x].unpack();
        }
    } 

    // Run a switch in slow motion if needed...
    // This is a simulated delay for the points to actually move, so the final indication packet
    // generated by a change from Normal to Reverse (or vice versa) isn't sent immediatly.  
    for (int x = 0; x < getNumSwitches(); x++) {
        Switch::Timer cc = sw[x].runSlowMotion();
        somethingchanged |= (cc == Switch::EXPIRED);
    }
    return somethingchanged;
}

/*
 * write out all the output device bits to the layout
 */
void ControlPoint::writeall(void) {
    // Take high level state and pack it up for output to the layout
    for (int x = 0; x < getNumPorts(); x++) {
        m[x].next = 0;    /// Start with a known state
    }
    // pack new "output" bits 
    // Switches  
    for (int x = 0; x < getNumSwitches(); x++) { 
        sw[x].pack();
    }
    // Signals  
    // for (int x = 0; x < getNumSignals(); x++) { 
    //     sig[x].pack();
    // }
    // Maintainer Call(s)
    for (int x = 0; x < getNumCalls(); x++) { 
        mc[x].pack();
    }
    for (int x = 0; x < getNumPorts(); x++) {
        m[x].put();   // push the .next contents out to the field
    }
}


/*
 * Evaluate the dependencies in a route statement
 * 
 * Example: sig[SIG2SA] = (evaluateevaluate(" SW1   SW3  (SW5) SIG2(RIGHT) SIG2SA(FLEET,ER) K2NAAT H2NA") 
 *
 * Signal 2S head A can be set to NON-STOP if
 * SW1 and SW3 are normal,
 * SW 5 is reversed  
 * SIG2 (the cTc commanded direction) is set to RIGHT
 * the 2SA mast/head hasthe engine return or FLEET stick relay energized (TBD...)
 * the track circuit 2NAA (the track this route leads to) must be clear
 * and Signal Head 2NA (allowing traffic from the other direction) must be at STOP
 *
 */
static char subtokens[40];

int ControlPoint::getSignal(char *name) {
	int x;
	for (x = 0; x < getNumSignals(); x++) { 
		if (sig[x].named(name)) break;
	}
	return (x != getNumSignals()) ? x : -1;
}
int ControlPoint::getSwitch(char *name) {
	int x;
	for (x = 0; x < getNumSwitches(); x++) { if (sw[x].named(name)) break; }
	return (x != getNumSwitches()) ? x : -1;
}
int ControlPoint::getHead(char *name) {
	int x;
	for (x = 0; x < getNumHeads(); x++) { if (head[x].named(name)) break; }
	return (x != getNumHeads()) ? x : -1;    
}
int ControlPoint::getTrack(char *name) {
	int x;
	for (x = 0; x < getNumTrackCircuits(); x++) { if (track[x].named(name)) break; }
	return (x != getNumTrackCircuits()) ? x : -1;
}


#if 0
static ControlPoint::mostRestrictive(RRSignalHead::Aspects current, RRSignalHead::Aspects desired) {
	return ((int) current < (int) desired) ? desired : current;
}
#endif

// Switches can be represented as
//     SW1    -or-     (SW1)
// meaning "must be Normal" or "(must be Reverse)"
RRSignalHead::Aspects ControlPoint::A_Switch(char *name, char *token) {
		RRSignalHead::Aspects aspect = RRSignalHead::CLEAR;
		Switch::State desiredState;
		int x= getSwitch(name);
		if (x == -1) {
				aspect = RRSignalHead::STOP; // no such switch
		} else {
			if (*token == '(') { desiredState = Switch::REVERSE; } 
			else               { desiredState = Switch::NORMAL; }
			if (! sw[x].is(desiredState)) {	// Not what is expected
				aspect = RRSignalHead::STOP;
			}
	    }
		return aspect;
}

// Signals can be
// SIG2    -or-    SIG2(xxx,xxx)
// meaning must be at stop  
//   -or-
// Signal has named "stick" values set
// Values can be
//		RIGHT, LEFT		- indicating a signal dependency
//		FLEET			- is the FLEET "relay" set?
//		ER				- is the interlocking in a Engine Return state (a cut of cars left on main when switching a siding)?

RRSignalHead::Aspects ControlPoint::A_Signal(char *name, char*token) {
	RRSignalHead::Aspects aspect = RRSignalHead::CLEAR;
	char *i2;
	int x = getSignal(name);
	if (x == -1) return RRSignalHead::STOP;
	char *subtoken_idx = strchr(name, '('); // )
	if (subtoken_idx) {			// Grab the values in their own string array...
		strcpy(subtokens, subtoken_idx+1); // Skip the '('
		subtokens[strlen(subtokens) - 1] = '\0'; // stomp on the trailing ')'
		*subtoken_idx = '\0';
		for (subtoken_idx = subtokens; ; subtoken_idx = NULL) {
			char *subtoken = strtok_r(subtoken_idx, ",", &i2);
			if (subtoken == NULL) { break; }
			if        (strcmp(subtoken, "RIGHT") == 0) { if (!sig[x].is(RRSignal::RIGHT))        { aspect = RRSignalHead::mostRestrictive(aspect, RRSignalHead::CLEAR); }
			} else if (strcmp(subtoken, "LEFT")  == 0) { if (!sig[x].is(RRSignal::LEFT))         { aspect = RRSignalHead::mostRestrictive(aspect, RRSignalHead::CLEAR); } 
			} else if (strcmp(subtoken, "FLEET") == 0) { if (!sig[x].stick() == RRSignal::FLEET) { aspect = RRSignalHead::mostRestrictive(aspect, RRSignalHead::CLEAR); } 
			} else if (strcmp(subtoken, "ER")    == 0) { if (!sig[x].stick() == RRSignal::ER)    { aspect = RRSignalHead::mostRestrictive(aspect, RRSignalHead::RESTRICTING); } 
			} else                                                                               { aspect = RRSignalHead::mostRestrictive(aspect, RRSignalHead::STOP); // invalid field token
			}
		}
	} else {
		if (!sig[x].is(RRSignal::ALLSTOP)) {  // Opposing signal not at STOP
			aspect = RRSignalHead::mostRestrictive(aspect, RRSignalHead::STOP); 
		}
	}
	return aspect;
}

RRSignalHead::Aspects ControlPoint::A_Approach(char *name, char *token) {
	RRSignalHead::Aspects aspect     = RRSignalHead::CLEAR;
	RRSignalHead::Aspects tempaspect = RRSignalHead::CLEAR;
	if      (name[1] == 'A') { tempaspect = RRSignalHead::ADVANCED_APPROACH;}	// AA(TRACK,TRACK...)
	else if (name[1] == '(') { tempaspect = RRSignalHead::APPROACH;}			// A(TRACK,TRACK...)
	else                     { tempaspect = RRSignalHead::STOP;}				// A?(TRACK,TRACK...) - anything else is a syntax error...
	
	char *i2;
	char *subtoken_idx = strchr(name, '(');
	if (subtoken_idx) {
		strcpy(subtokens, subtoken_idx+1);
		subtokens[strlen(subtokens) - 1] = '\0'; // stomp on the trailing ')'
		*subtoken_idx = '\0';
	} else {
		subtokens[0] = '\0';
	}
	
	// subtokens is the list of tracks which, if occupied, should result in tempaspect being the signal state...
	boolean myOR = 0;
	if (subtokens[0]) {
		for (subtoken_idx = subtokens; ; subtoken_idx = NULL) {
			char *subtoken = strtok_r(subtoken_idx, ",", &i2);
			if (subtoken == NULL) {
				break;
			}
			int x = getTrack(subtoken);
			if (x == -1) {
				return RRSignalHead::STOP;
			}
			myOR |= track[x].is(TrackCircuit::OCCUPIED); 
		}
		aspect = ((myOR) ? tempaspect : RRSignalHead::CLEAR);
	}
	return aspect;
}

// Track Circuits - occupied => STOP
RRSignalHead::Aspects ControlPoint::A_Track(char *name, char*token) {
	RRSignalHead::Aspects aspect = RRSignalHead::STOP;
	// Track Circuit
	int x = getTrack(name);
	if (x != -1) {
		aspect = (track[x].is(TrackCircuit::EMPTY)) ? RRSignalHead::CLEAR : RRSignalHead::STOP;
	}
	return aspect;
}

char name[40];
// Caution:  Modifys char *input
RRSignalHead::Aspects ControlPoint::Evaluate(char *input) {	
	RRSignalHead::Aspects aspect = RRSignalHead::CLEAR;
	name[0] = '\0';
	char *str, *token, *i1;
	if (strlen(input) >= 75) { return RRSignalHead::STOP; }
	for (str = input; ; str = NULL) {
		if (aspect == RRSignalHead::STOP) { return aspect; }
	    token = strtok_r(str, " ", &i1);  // walk thru input getting tokens, put token value into "name"
	    if (token == NULL) { break; }
	    
	    if (*token == '(') {  // (name) - we want to strip the parenthisis, giving token = "(xxx)" and name = "xxx"
	        strcpy(name, token+1);
	        name[strlen(name) -1] = '\0';
	    } else {              // name  or name(value,value)
	        strcpy(name,token);
	    }
		// We have a token, now evaluate it...
		if      ((name[0] == 'S') && (name[1] == 'W')) 						aspect = RRSignalHead::mostRestrictive(aspect, A_Switch(name, token));	// SW1
		else if ((name[0] == 'S') && (name[1] == 'I'))						aspect = RRSignalHead::mostRestrictive(aspect, A_Signal(name, token)); 	// SIG2 or SIG4(stick,values)
		else if ((name[0] == 'A'))											aspect = RRSignalHead::mostRestrictive(aspect, A_Approach(name, token));// AA(TRACK,TRACK...) or A(TRACK,TRACK...)
	    else if ((name[0] == 'T') || (name[0] == 'W') || (name[0] == 'E'))	aspect = RRSignalHead::mostRestrictive(aspect, A_Track(name, token));	// T1, WA1 EA2
	}
	return aspect;
}    

void ControlPoint::initializeCodeLine(int lnrx, int lntx) {
    pinMode(lntx, OUTPUT);     // Loconet Send Data     (7)
    pinMode(lnrx, INPUT);      // Loconet RxD			(8)
    LocoNet.init();     // initialize the LocoNet interface
}


int ControlPoint::sendCodeLine(int from, int to, int *indications) {

	lnMsg SendPacket ;

	SendPacket.data[ 0 ] = OPC_PEER_XFER ;
	SendPacket.data[ 1 ] = 0x10;                // packet length
	SendPacket.data[ 2 ] = (from);              // SRC
	SendPacket.data[ 3 ] =  (to & 0x7F);        // DSTL
	SendPacket.data[ 4 ] =  (to >> 7) & 0x7F;   // DSTH 

	int pxct = 0x00;
	if (indications[0] & 0x80) pxct |= B0001;
	if (indications[1] & 0x80) pxct |= B0010;
	if (indications[2] & 0x80) pxct |= B0100;
	if (indications[3] & 0x80) pxct |= B1000;

	SendPacket.data[ 5 ] =  pxct;    // pxct1
	SendPacket.data[ 6 ] = indications[0] & 0x7F;  
	SendPacket.data[ 7 ] = indications[1] & 0x7F;  
	SendPacket.data[ 8 ] = indications[2] & 0x7F;  
	SendPacket.data[ 9 ] = indications[3] & 0x7F;  

	pxct = 0x10;
	if (indications[4] & 0x80) pxct |= B0001;
	if (indications[5] & 0x80) pxct |= B0010;
	if (indications[6] & 0x80) pxct |= B0100;
	if (indications[7] & 0x80) pxct |= B1000;

	SendPacket.data[ 10 ] = pxct;    // pxct2
	SendPacket.data[ 11 ] = indications[4] & 0x7F;  
	SendPacket.data[ 12 ] = indications[5] & 0x7F;  
	SendPacket.data[ 13 ] = indications[6] & 0x7F;  
	SendPacket.data[ 14 ] = indications[7] & 0x7F;   
	 
    byte checksum = 0xFF; 
	for (int i = 0; i < 15; i++) {
      checksum ^= SendPacket.data[i];
    }
    SendPacket.data[ 15 ] = checksum; //checksum  
#ifdef DEBUG  
    Serial.print("Send: OPC_PEER_XFER ");
	ControlPoint::printLnPacket(&SendPacket);
#endif
    return (int)LocoNet.send( &SendPacket );   
}

boolean ControlPoint::LnPacket2Controls(int *src, int *dst, int *controls) {
	lnMsg *LnPacket;
	if ((LnPacket = LocoNet.receive())) {
	    unsigned char opcode = (int)LnPacket->sz.command;
	    *src = (byte)LnPacket->px.src;
	    *dst = (((byte)LnPacket->px.dst_h & 0x7f) << 7) | ((byte)LnPacket->px.dst_l & 0x7f);
	    if (opcode == OPC_PEER_XFER) {
	        controls[0] = (byte)LnPacket->px.d1;  
	        controls[1] = (byte)LnPacket->px.d2;  
	        controls[2] = (byte)LnPacket->px.d3;
	        controls[3] = (byte)LnPacket->px.d4;
	        controls[4] = (byte)LnPacket->px.d5;  
	        controls[5] = (byte)LnPacket->px.d6;  
	        controls[6] = (byte)LnPacket->px.d7;
	        controls[7] = (byte)LnPacket->px.d8;
	        if ((byte)LnPacket->px.pxct1 & B00000001) controls[0] |= B10000000;
	        if ((byte)LnPacket->px.pxct1 & B00000010) controls[1] |= B10000000;
	        if ((byte)LnPacket->px.pxct1 & B00000100) controls[2] |= B10000000;
	        if ((byte)LnPacket->px.pxct1 & B00001000) controls[3] |= B10000000;
         
	        if ((byte)LnPacket->px.pxct2 & B00000001) controls[4] |= B10000000;
	        if ((byte)LnPacket->px.pxct2 & B00000010) controls[5] |= B10000000;
	        if ((byte)LnPacket->px.pxct2 & B00000100) controls[6] |= B10000000;
	        if ((byte)LnPacket->px.pxct2 & B00001000) controls[7] |= B10000000;
	        return true;
	    }
    }
    return false;
}

#ifdef DEBUG
void ControlPoint::printEverything(void) {
	int x;
	Serial.println("----");
	for (x = 0; x < getNumSignals(); x++) 		{ sig[x]  .print(); Serial.println();}
	for (x = 0; x < getNumSwitches(); x++)		{ sw[x]   .print(); Serial.println();}
	for (x = 0; x < getNumHeads(); x++)			{ head[x] .print(); Serial.println();}
	for (x = 0; x < getNumTrackCircuits(); x++) { track[x].print(); Serial.println();}
	for (x = 0; x < getNumCalls(); x++) 		{ mc[x]   .print(); Serial.println();}
}

void ControlPoint::printBin(byte x) { // 0 1 2 3 4 5 6 7
	char buff[8+1];
    for (int i = 0; i < 8; i++) {
		buff[i] = (bitRead(x,i) ? '1' : '0');
    }
	buff[8] = '\0';
    Serial.print(buff);
}
void ControlPoint::printBinReverse(byte x) { // 7 6 5 4 3 2 1 0
	char buff[8+1];
    for (int i = 0; i < 8; i++) {
		buff[7-i] = (bitRead(x,i) ? '1' : '0');
    }
	buff[8] = '\0';
    Serial.print(buff);
}
void ControlPoint::printBinOriginal(byte x) {
    for (int i = 7; i >= 0; i++) {
        if (x < pow(2, i)) {
            Serial.print(B0);
        }
    }
    if (x != 0) Serial.print(x, BIN );
}

void ControlPoint::printControls(int from, int to, int *controls) {
	ControlPoint::printPacket("Controls",from, to, controls);
}
void ControlPoint::printIndications(int from, int to, int *indications) {
	ControlPoint::printPacket("Indications",from, to, indications);
}
void ControlPoint::printPacket(char *name, int from, int to, int *packet) {
	Serial.print(name);Serial.print(": FROM: "); Serial.print(from, DEC); Serial.print(", TO: ");Serial.print(to, DEC);Serial.println();
	for (int x = 0; x < 8; x++) {
		Serial.print(x,DEC); Serial.print(": [");ControlPoint::printBin(packet[x]);Serial.print("]\n");
	}
}

void ControlPoint::printLnPacket(lnMsg *LnPacket) {
    uint8_t msgLen = getLnMsgSize(LnPacket); 
    unsigned char opcode = (int)LnPacket->sz.command;
    if (opcode == OPC_PEER_XFER) {
        Serial.print  (LnPacket->data[0], HEX); Serial.print(" "); Serial.println(LnPacket->data[1], HEX); 
        Serial.print("    SRC  = 0x"); Serial.println(LnPacket->data[2], HEX);
        Serial.print("    DST  = 0x"); Serial.print(LnPacket->data[3], HEX);Serial.print(" 0x"); Serial.print(LnPacket->data[4], HEX); Serial.print(" = ");
            Serial.println((LnPacket->data[3] & 0x7F) | ((LnPacket->data[4] & 0x7F) << 7));
        Serial.print("    PXCT1, D1-4  = "); printBin(LnPacket->data[5]); Serial.print(": ");
            for (int x = 6; x <= 9; x++) {    Serial.print(" ");printBin(LnPacket->data[x]);  } Serial.println("");
        Serial.print("    PXCT2, D5-8  = "); printBin(LnPacket->data[10]); Serial.print(": ");
            for (int x = 11; x <= 14; x++) {    Serial.print(" ");printBin(LnPacket->data[x]);  } Serial.println("");
        Serial.print("    CHK  = 0x"); Serial.println(LnPacket->data[15], HEX);
    } else for (uint8_t x = 0; x < msgLen; x++) {
      uint8_t val = LnPacket->data[x];
      if (val < 2)   Serial.print('0');
      if (val < 4)   Serial.print('0'); 
      if (val < 8)   Serial.print('0');  
      if (val < 16)  Serial.print('0');  
      if (val < 32)  Serial.print('0'); 
      if (val < 64)  Serial.print('0');
      if (val < 128) Serial.print('0');
      Serial.print(val, BIN);
      Serial.print(' ');
    }
}
#endif

